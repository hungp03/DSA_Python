# -*- coding: utf-8 -*-
"""CTDLGT_ThuchanhBuoi01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vaKfea08xXUaaMEkbXtHusGkrk49uEIH
"""

t = (1, 2, 3)

print(t[0])
print(t[1])
print(t[2])

"""Trong đoạn trên, t[0] tương ứng với phần tử đầu tiên, t[1] là phần tử thứ 2 và t[2] là phần tử thứ 3"""

t = 1, 2
print(t)
print(type(t))

"""Trong python, ta có thể tạo một tuple mà không cần dùng đến ngoặc đơn nếu tuple đó có 2 phần tử trở lên, nếu có một phần tử, ta cần khai báo dạng `(element,)`"""

singleton = (1, )
singleton

var1 = (1 + 2) * 5
print(type(var1), ' ', var1)

var2 = (1)
print(type(var2), ' ', var2)

var3 = (1,)
print(type(var3), ' ', var3)

"""Trong đoạn code trên, var1 là phép nhân của tổng (1 + 2), không phải là tuple nên kết quả trả về là `3 * 5 = 15`

var2 khai báo theo kiểu số nguyên, nếu muốn khai báo tuple thì cần làm như sau: `var2 = (1)`

var3 là 1 cách khai báo tuple, nên kết quả sẽ trả về dạng tuple

Chúng ta cũng có thể lặp tuple bằng cách nhân tuple với một số thay vì phải nối tuple
"""

t = (1,) * 5
print(t)

"""Chúng ta cũng có thể nối tuple bằng cách dùng phép +="""

t1 = (1, 0)
print(t1)

t1 += (2,)
print(t1)

"""## Tuple methods

`count(x)`: Sử dụng để đếm số lượng phần tử có giá trị là `x`

`index(x)`: tìm vị trí đầu tiên của phần tử `x` trong tuple
"""

t = (1,2,3,1)
count = t.count(1)
index = t.index(2)

print(count)
print(index)

"""#### Tuples cặp khóa / giá trị để xây dựng dictionary

Ta có thể sử dụng tuple như là một phần tử trong dictionary với phần tử đầu tiên trong tuple là khóa (`key`) và phần tử thứ 2 là giá trị (`value`)
"""

d = dict([('jan', 1), ('feb', 2), ('march', 3)])

print(d['jan'])
print(d['feb'])
print(d['march'])

"""#### Get multiple values"""

x1,y1,z1   = ('a','b','c')
(x2,y2,z2) = ('a','b','c')
(x3,y3,z3) = range(3)

print(x1)
print(x2)
print(x3)

"""Mỗi giá trị trong tuple `('a', 'b', 'c')` tương ứng với một biến trong dãy biến được gán. Sau khi thực hiện, `x1` sẽ có giá trị `'a'`, `y1` có giá trị `'b'`, và `z1` có giá trị `'c'`

Tương tự với `x2, y2, z2`

Trong dòng cuối cùng, `x3, y3, z3` được gắn với một dãy số chạy từ 0 -> 2. Cuối cùng kết quả trả về là `x3` = `0`, `y3` = `1`, `z3` = `2`

Đoạn dưới đây tương tự như `x3, y3, z3`
"""

(x,y,z) = range(3)
print(x,y,z)

a = range(3)
print(type(a))

"""Đoạn code phía trên sẽ sử dụng một class `range`, là class sử dụng cho việc lặp. Ở đây, `a` là một đối tượng `range` lặp từ 0 đến 2"""

d = {'first':'string value', 'second':1}
for a in d:
    print(a)

"""Trong đoạn code trên, ta sử dụng một vòng lặp để duyệt qua các phần tử của một dictionary và in ra key của nó

Để lấy cả `key` và `value`, ta sử dụng phương thức `items()`
"""

d = {'first':'string value', 'second':[1,2]}
items = d.items()
print('items:', items)
for k,v in items:
    print(k, v)

"""#### Tuple unpacking

Tuple unpacking cho phép trích xuất các phần tử tuple tự động là danh sách các biến ở bên trái có cùng số phần tử với độ dài của tuple, ở đây `x` sẽ lấy phần tử đầu tiên của tuple `data`
"""

data  = (1,2,3)
x, y, z = data
print(x)

"""Ta cũng có thể sử dụng tuple để đảo ngược giá trị của các phần tử"""

x = 4
y = 5

print(x, y)

(x,y) = (y,x)
print(x, y)

"""Viết 1 hàm để swap 2 số dùng tuple

Cách hoạt động tương tự như việc dùng biến tạm

`v1` gắn bằng `v2`, `v2` gắn ngược lại bằng `v1`
"""

def swap(v1, v2):
    (v2, v1) = (v1, v2)
    return (v1, v2)

v1 = 2
v2 = 3
(v1, v2) = swap(v1, v2)

# print
print(v1)
print(v2)

"""#### Misc

Để tìm độ dài của tuple, ta sử dụng phương thức `len`. Phương thức này sẽ đếm số phần tử có trong tuple và trả về một số nguyên không âm duy nhất
"""

t = (1, 2, 3, 4)
len(t)

"""Slicing"""

data = (1, 2, 3, 4, 5)
print(data[2:])
print(data[::-1])

"""`print(data[2:])` sẽ lấy các phần tử từ vị trí thứ 2 đến cuối tuple

`print(data[::-1])` lấy tất cả các phần tử nhưng theo hướng ngược lại

#### Copy tuple
"""

from copy import copy
t = (1, 2, 3, 4, 5)

new_t = copy(t)
print(new_t)

"""Sử dụng thư viện copy để copy một tuple. Lưu ý rằng khi thay đổi ở tuple dùng phương thức `copy ` thì tuple chính cũng thay đổi, `deepcopy` sẽ không làm thay đổi

#### Tuple are not fully immutable

Mặc dù các tuple không thể thay đổi (immutable), nhưng nếu chúng chứa các đối tượng có thể thay đổi (mutable), thì vẫn có thể thay đổi nội dung của các đối tượng đó bên trong tuple

Ví dụ dưới cho thấy nếu list ở bên trong tuple, ta vẫn có thể thay đổi giá trị trong list đó
"""

t = (1, 2, [3, 10])
t[2][0] = 9
print(t)

t = (1, 2, [3, 10])
t[2][1] = 4
print(t)

"""Mặt khác, nếu tuple không chứa các đối tượng có thể thay đổi, thì nó sẽ trả về lỗi khi có gắng thay đổi

"""

# tuple_immutable = (1, 2, 3)
# tuple_immutable[0] = 4

"""Chúng ta cũng có thể đổi tuple sang chuỗi bằng cách dùng `str`"""

data = (1, 2, 3, 4, 5)
data_str = str(data)
print(data_str)
print(type(data_str))

print(data_str[0])

"""Ta cũng có thể dùng các hàm toán học và các phép so sánh trên tuple"""

t = (1, 2, 3, 4, 5)

print(min(t))
print(max(t))
print(sum(t))

t = (4, 7, 3, 9, 6)
t_s = sorted(t)
print(t_s)

"""hàm `sorted` sẽ tạo một list mới là các phần tử trong tuple, sắp theo thứ tự tăng dần"""

t1 = (1, 2, 3, 4, 5)
t2 = ('a', 'b', 'c', 'd', 'e')

print(t1)
print(t2)

t3 = zip(t1, t2)
for x,y in t3:
    print(x, y)

"""Hàm `zip` sẽ đóng gói các dữ liệu của `t1` và `t2` theo thứ tự, ví dụ: `(1,a)`, `(2,b)` dưới dạng các tuple ...

Sau đó duyệt qua vòng for để lấy dữ liệu và in kết quả ra màn hình
"""

import math

def quadratic_equation(a, b, c):
    '''
    This function aims at solving the quadratic equation
    a, b, c --- three parameters and a =! 0
    '''

    # compute delta
    delta = b*b - 4*a*c

    if delta < 0:
        return ()
    elif delta == 0:
        x = (-b+math.sqrt(delta))/2*a
        return (x,)
    else:
        x1 = (-b+math.sqrt(delta))/(2*a)
        x2 = (-b-math.sqrt(delta))/(2*a)
        return (x1,x2)

"""quadratic_equation sẽ trả về một tuple chứa các nghiệm của phương trình bậc hai. Nếu không có nghiệm thực, nó sẽ trả về một tuple rỗng"""

result = quadratic_equation(a=5, b=0, c=1)
print(type(result))
print(len(result))
print(result)

result = quadratic_equation(a=5, b=5, c=1)
print(type(result))
print(len(result))
print(result)

result = quadratic_equation(a=4, b=4, c=1)
print(type(result))
print(len(result))
print(result)

# result = quadratic_equation(a=4, b=4, c=1)
# result[0] = 1

"""Đoạn code trên thực thi không thành công vì kết quả trả về của hàm `quadratic_equation` là một tuple thuần túy nên nó không cho phép thay đổi giá trị (immutable)

#### Tuple and zip
"""

x_data = [1, 2, 3]
y_data = [5, 6, 7]
data = zip(x_data, y_data)

# print
for d in data:
    print(d)
    print(type(d))

"""phương thức `zip` sẽ đóng gói phần tử từ các iterable thành các tuple với mỗi tuple chứa các phần tử có cùng vị trí từ các iterable tương ứng

### Tuple and list
"""

# memory comparison
import sys

aList  = [3, 4, 5, 6, 7]
aTuple = (3, 4, 5, 6, 7)

print(sys.getsizeof(aList))
print(sys.getsizeof(aTuple))

"""Phương thức `getzieof` sẽ lấy về kích thước của một đối tượng. Ở đây kết quả cho thấy rằng `tuple` sử dụng ít bộ nhớ hơn so với `list`

Chuyển `list` sang `tuple` bằng cách ép kiểu
"""

# convert from list to tuple
aList  = [3, 4, 5, 6, 7]
aTuple = tuple(aList)

print(aTuple)
print(type(aTuple))

"""Ngược lại, chuyển `tuple` sang `list`"""

# convert from tuple to list
aTuple  = (3, 4, 5, 6, 7)
aList = list(aList)

print(aList)
print(type(aList))
# -*- coding: utf-8 -*-
"""Dict.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GmzPTP5T3DSBpybdW54wi9dUTdLY2ctU

### Dicts

####  Methods to create new dictionary

d1 cũng thay đổi theo d2 vì nó cùng tham chiếu đến 1 đối tượng
"""

d1 = {'a': [1,2]}
d2 = d1
d2['a'] = [1,2,3,4]
d1['a']

"""Để tạo một đối tượng mới, sử dụng phương thức sao chép, Để tránh việc thay đổi cùng 1 đối tượng và tạo ra một bản sao độc lập của d1, ta có thể sử dụng phương thức copy():"""

d1 = {'a': [1,2]}
d2 = d1.copy()

d2['a'] = [1,2,3]
print('d1:', d1)
print('d2:', d2)

"""khi sử dụng phương thức copy() để sao chép một dictionary chứa các đối tượng có tham chiếu, thì các tham chiếu đến các đối tượng đó vẫn được giữ nguyên."""

d1 = {'a': [1,2], 'b': 5}
d2 = d1.copy()

# thay đổi giá trị d2 sẽ ảnh hưởng đến d1
d2['a'][0] = 3
d2['a'][1] = 4

print('d1:', d1)
print('d2:', d2)

"""Để tránh tình trạng này, ta cần thực hiện một sao chép sâu (deepcopy) thay vì một copy bình thường. Chúng ta có thể sử dụng thư viện copy để thực hiện sao chép sâu"""

import copy

d1 = {'a': [1,2], 'b': 5}
d2 = copy.deepcopy(d1)

# thay đổi giá trị d2
d2['a'][0] = 3
d2['a'][1] = 4

print('d1:', d1)
print('d2:', d2)

"""Xóa một từ điển (nghĩa là xóa tất cả các mục của nó) bằng phương thức clear ():"""

d = {'a': [1,2], 'b': 5}
print(d)

d.clear()
print(d)

"""Phương thức clear () xóa tất cả các mục trong khi del () xóa chỉ một mục trong dictionary:"""

d = {'a':1, 'b':2, 'c':3}
del d['a']
print(d)

"""Tạo một mục mới với giá trị mặc định (nếu không được cung cấp, Không có gì là mặc định):"""

d1 = {'a': [1,2]}
d2 = d1.copy()
d2.setdefault('third', '')
d2['third']
print(d2)

"""Tạo một từ điển cho một bộ khóa (key):"""

d1 = {'a': [1,2]}
d2 = d1.copy()
d2.fromkeys(['first', 'second'])

"""Ta có một cách tương tự như trên"""

{}.fromkeys(['first', 'second'])

"""Phương thức fromkeys () tạo ra một từ điển mới với các khóa đã cho,
mỗi khóa có giá trị tương ứng mặc định là None.

####  Combining dictionaries

Cho 2 từ điển d1 và d2, bạn có thể thêm tất cả các cặp key/ value từ d2 vào d1 bằng cách sử dụng phương thức `update()` (thay vì lặp và tự gán từng cặp):

`d1.update(d2)` sẽ cập nhật các cặp key-value từ d2 vào d1.
"""

d1 = {'a':1}
d2 = {'a':2, 'b':2}
d1.update(d2)
d1['a']

d1 = {'a':1}
d2 = {'b':2, 'c':3}

print('d1:', d1)
print('d2:', d2)

d1.update(d2)
print('d1 sau khi update:', d1)

"""Các mục trong từ điển được cung cấp được thêm vào từ cũ, ghi đè bất kỳ mục nào có cùng khóa

####  iterators

Từ điển cung cấp các trình vòng lặp trên các giá trị, khóa hoặc các mục

Lưu ý chỉ chạy được trên Python 2, Python 3 cần thay đổi sang values(), keys(), và items()
"""

# d1 = {'a': 1, 'b': 2, 'c': 3}

# # Sử dụng itervalues()
# values = [x for x in d1.itervalues()]

# # Sử dụng iterkeys()
# keys = [x for x in d1.iterkeys()]

# # Sử dụng iteritems()
# items = [x for x in d1.iteritems()]

# print("Values:", values)
# print("Keys:", keys)
# print("Items:", items)

d1 = {'a': 1, 'b': 2, 'c': 3}

# Sử dụng values()
values = [x for x in d1.values()]

# Sử dụng keys()
keys = [x for x in d1.keys()]

# Sử dụng items()
items = [x for x in d1.items()]

print("Values:", values)
print("Keys:", keys)
print("Items:", items)

""" Sử dụng hàm zip() để ghép các phần tử từ hai danh sách l_keys và l_values thành các cặp key-value. Sau đó, comprehension được sử dụng để tạo ra một dictionary từ các cặp key-value này"""

l_keys   = ['a', 'b', 'c', 'd', 'e']
l_values = [1, 2, 3, 4, 5]

d = {(k,v) for (k,v) in zip(l_keys,l_values)}
print(d)

"""viewkey, viewvalues, viewitems là các đối tượng giống như tập hợp cung cấp chế độ xem trên các key, value của D.

#### comparison

Sử dụng comprehension để tạo một dictionary. Với mỗi giá trị i trong phạm vi từ 0 đến 4 (tức là range(5)), nó tạo ra một cặp key-value với key là chuỗi biểu diễn của i (tức là str(i)) và giá trị là i.
"""

# dic comprehension

aDict = {str(i):i for i in range(5)}
print(aDict)

"""sử dụng hàm zip() để ghép cặp các phần tử từ tuple1 và tuple2, sau đó chuyển đổi thành một dictionary bằng cách sử dụng hàm dict().

zip(tuple1, tuple2) tạo ra một iterator chứa các cặp (key, value) với key lấy từ tuple1 và value lấy từ tuple2. Trong trường hợp này, cặp (1, 4), (2, 5), (3, 6) được tạo ra.
"""

# from zip

tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)

a_dict = dict(zip(tuple1, tuple2))
print(type(a_dict))
print(a_dict)

"""Tương tự như trên, chỉ khác ở đầu vào là set thay vì tuple"""

# from zip

set1 = {1, 2, 3}
set2 = {4, 5, 6}

a_dict = dict(zip(set1, set2))
print(type(a_dict))
print(a_dict)

"""Tương tự như trên, chỉ khác ở đầu vào là list


"""

# from zip

list1 = [1, 2, 3]
list2 = [4, 5, 6]

a_dict = dict(zip(list1, list2))
print(type(a_dict))
print(a_dict)

"""Không có key -> lỗi KeyError"""

# setdefault()

fruits = {'banana': 2}

fruits['apple'] += 10
print(fruits)

"""Không có dict cereal"""

# merge two dicts

# fruits = {'banana': 2, 'apple': 4}
# result = {**fruits, **cereal}
# print(**fruits)

"""sử dụng cú pháp ** để gộp hai dictionaries fruits và cereal thành một dictionary mới, `result`"""

# merge two dicts

fruits = {'banana': 2, 'apple': 4}
cereal = {'rice': 3, 'corn': 7}

result = {**fruits, **cereal}
print(result)

"""Kiểm tra key có tồn tại hay không bằng `in`"""

# check if a key exists

fruits = {'banana': 2, 'apple': 4}

print('apple' in fruits)
print('corn' in fruits)

"""Loại bỏ key không có giá trị bằng cách tạo dict mới và duyệt các phần tử có value khác `None`"""

# remove empty items

fruits = {'banana': 2, 'apple': None}

dict1 = {key:value for (key, value)
                     in fruits.items()
                     if value is not None}
print(dict1)

"""Dùng `get` để lấy value từ key, không có trả về None"""

# access value via key

fruits = {'banana': 2, 'apple': 4}
print(fruits.get('apple'))
print(fruits.get('corn'))

"""Nếu dùng cách thông thường thì gây lỗi KeyError khi truy xuất key không tồn tại"""

# access value via key

fruits = {'banana': 2, 'apple': 4}
print(fruits['apple'])
print(fruits['corn'])

"""## Dictionary and File

json.dump(parameters, fp) ghi nội dung của dictionary parameters vào tệp tin được mở với quyền ghi ('w'). Trong trường hợp này, dictionary parameters sẽ được ghi vào tệp tin data.json.
"""

import json

parameters = {'learning_rate': 0.1,
              'optimizer': 'Adam',
              'metric': 'Accuracy'}

with open('data.json', 'w') as fp:
    json.dump(parameters, fp)

"""json.load(fp) đọc nội dung của tệp tin JSON đã mở và chuyển đổi nó thành một dictionary. Trong trường hợp này, nội dung của tệp tin 'data.json' sẽ được đọc và chuyển đổi thành dictionary data"""

with open('data.json', 'r') as fp:
    data = json.load(fp)
    print(data)

print(data['learning_rate'])

"""## Iterables and Sorting"""

# create a list
aList = [1, 5, 3, 7, 4]
print(aList)

# sort
sortedList = sorted(aList)
print(sortedList)

# create a list
aList = [1, 5, 3, 7, 4]
print(aList)

# function for sorting
def compare(item):
    return item

# sort
sortedList = sorted(aList, key=compare)
print(sortedList)

# data
list1 = [1, 5, 3, 7, 4]
list2 = [16, 13, 18, 11, 15]

# create a dictionary
dictionary = dict(zip(list1, list2))
print(dictionary)

sortedDict = sorted(dictionary)
print(sortedDict)

# data
list1 = ['a', 'g', 'e', 'h', 'b']
list2 = [16, 13, 18, 11, 15]

# create a dictionary
list3 = list(zip(list1, list2))
print(list3)

list4 = sorted(list3)
print(list4)



# data
list1 = ['a', 'g', 'e', 'h', 'b']
list2 = [16, 13, 18, 11, 15]

# function for sorting
def compare(item):
    return item[0]

# create a dictionary
list3 = list(zip(list1, list2))
print(list3)

list4 = sorted(list3, key=compare)
print(list4)



# data
list1 = ['a', 'g', 'e', 'h', 'b']
list2 = [16, 13, 18, 11, 15]

# function for sorting
def compare(item):
    return item[1]

# create a dictionary
list3 = list(zip(list1, list2))
print(list3)

list4 = sorted(list3, key=compare)
print(list4)

# data
list1 = ['a', 'g', 'e', 'h', 'b']
list2 = [16, 13, 18, 11, 15]

# create a dictionary
list3 = list(zip(list1, list2))
print(list3)

list4 = sorted(list3, key=lambda item: item[1])
print(list4)
# -*- coding: utf-8 -*-
"""3.1.IOU_Tuple.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m-JZwXa83yEiGqUfjjoRthd-fNi3Q3qC
"""

from google.colab import drive
drive.mount('/content/drive')

"""Hàm computeIoU(boxA, boxB) tính toán chỉ số IoU (Intersection over Union) giữa hai hộp giới hạn (bounding boxes) boxA và boxB.

Đầu tiên, nó xác định tọa độ của hình chữ nhật giao nhau bằng cách lấy giá trị lớn nhất của x và y giữa boxA và boxB, cũng như lấy giá trị nhỏ nhất của x và y. Điều này đảm bảo rằng hình chữ nhật giao nhau được tính toán chính xác.

Tiếp theo, nó tính diện tích của hình chữ nhật giao nhau.

Sau đó, nó tính diện tích của cả hai hộp giới hạn.

Cuối cùng, nó tính chỉ số IoU bằng cách chia diện tích của hình chữ nhật giao nhau cho tổng diện tích của cả hai hộp giới hạn trừ đi diện tích của hình chữ nhật giao nhau.

Kết quả là chỉ số IoU, cho biết mức độ trùng lắp giữa hai hộp giới hạn.
"""

def computeIoU(boxA, boxB):
	# determine the (x, y)-coordinates of the intersection rectangle
	xA = max(boxA[0], boxB[0])
	yA = max(boxA[1], boxB[1])
	xB = min(boxA[2], boxB[2])
	yB = min(boxA[3], boxB[3])

	# compute the area of intersection rectangle
	interArea = max(0, xB - xA + 1) * max(0, yB - yA + 1)
	# compute the area of both the prediction and ground-truth
	# rectangles
	boxAArea = (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1)
	boxBArea = (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1)
	# compute the intersection over union by taking the intersection
	# area and dividing it by the sum of prediction + ground-truth
	# areas - the interesection area
	iou = interArea / float(boxAArea + boxBArea - interArea)
	# return the intersection over union value
	return iou

boxA = (0,0,5,5)
boxB = (2.5,2.5,7.5,7.5)
error = computeIoU(boxA,boxB)
print(error)